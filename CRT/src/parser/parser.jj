/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. ./parser.jj */
/*@egen*/
/** 
 * Parser for the constraints.
 * by Vincent Hugot, 2009-10-4
 
 * This grammar has the following advantages over the one which was suggested:
 
  * More robust: Won't die if there are too many line feeds at the beginning or end...
  * Support for negative integers (the other did not!!)
  * AST expression trees correspond to the intuitive idea:
    +(2,3) instead of Exp(2,Exp(+,3)); visitors will be much
    easier to implement...
  * Expressions are (correctly) left-associative
  * Expressions support operator priorities
  * Supports parentheses to override priorities
    (the other had no priorities and no parens to explicitely
     specify them... the only possible way to get correct nesting would
     have been to introduce intermediary variables... a mess !)
  * Supports several constraints on one line, comma-separated
     
 * ... and the following difference
  * Domains must be grouped at beginning of file
    (can be seen as a restriction; 
     I see it as a cleaner way of doing things but YMMW)
  
**/

options {
             
               
  //NODE_PACKAGE="parser";
    // For some reason, this option generates brain-dead "import .*"
    // which prevent compilation of generated files. So we'll do without it.
}

PARSER_BEGIN(Parser)
    public class Parser/*@bgen(jjtree)*/implements ParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected static JJTParserState jjtree = new JJTParserState();

/*@egen*/}
PARSER_END(Parser)


/** LEXER */

SKIP : { 
  " " | "\r" | "\t" | "\n" 
}  

TOKEN : {

  /** Identifiers */

    < IDENTIFIER :  
      <LETTER> 
      | 
      (( <LETTER> | "_" ) ( <LETTER> | <DIGIT> | <SPECIALSYMB> )*) 
    >
  | < INTEGER :     ("-")? (<DIGIT>)+ >
  | < DIGIT :       ["0"-"9"] >
  | < LETTER :      ["a"-"z", "A"-"Z"] >
  | < SPECIALSYMB : ["_", "'"] >

  /** Symbols */

  | < LB:     "[" >
  | < RB:     "]" >
  | < LP:     "(" >
  | < RP:     ")" >
  | < BOUNDS: ",...," >
  | < COMMA:  "," >
  | < SEMICOLON: ";" >
  
  /** OPERATORS */

  | < DOMAIN_DEF:   "*:" >

  | < PLUS:         "*+" >
  | < MINUS:        "*-">
  | < TIMES:        "***" >
  | < DIV:          "*/" >

  | < NEQ:          "*/=" >
  | < EQ:           "*=" >

  | < LEQ:          "*=<" > 
  | < GEQ:          "*>=" >
  
  | < G:            "*>" >
  | < L:            "*<" >
  
} // END TOKENS 


/** PARSER */

void constraints() : {/*@bgen(jjtree) constraints */
  ASTconstraints jjtn000 = new ASTconstraints(JJTCONSTRAINTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} 
{/*@bgen(jjtree) constraints */
  try {
/*@egen*/
  domain_definition() (<COMMA> domain_definition())*
  <SEMICOLON>
  constraint() (<COMMA> constraint()) *
  <EOF>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void domain_definition()         : {/*@bgen(jjtree) domain */
  ASTdomain jjtn000 = new ASTdomain(JJTDOMAIN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) domain */
  try {
/*@egen*/
  variable() <DOMAIN_DEF> <LB> integer() <BOUNDS> integer() <RB>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}


void variable()      : {/*@bgen(jjtree) var */
  ASTvar jjtn000 = new ASTvar(JJTVAR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) var */
  try {
/*@egen*/
  <IDENTIFIER>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { 
       jjtn000.name = token.image; 
    }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void integer()          : {/*@bgen(jjtree) integer */
  ASTinteger jjtn000 = new ASTinteger(JJTINTEGER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) integer */
  try {
/*@egen*/
  <INTEGER>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
      jjtn000.value = Integer.parseInt(token.image);
    }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void cons_eq()     : {/*@bgen(jjtree) eq */
  ASTeq jjtn000 = new ASTeq(JJTEQ);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) eq */
   try {
/*@egen*/
   expression() <EQ> expression()/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}

void cons_leq()      : {/*@bgen(jjtree) leq */
  ASTleq jjtn000 = new ASTleq(JJTLEQ);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) leq */
   try {
/*@egen*/
   expression() <LEQ> expression()/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}

void cons_geq()      : {/*@bgen(jjtree) geq */
  ASTgeq jjtn000 = new ASTgeq(JJTGEQ);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) geq */
   try {
/*@egen*/
   expression() <GEQ> expression()/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}

void cons_neq()      : {/*@bgen(jjtree) neq */
  ASTneq jjtn000 = new ASTneq(JJTNEQ);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) neq */
   try {
/*@egen*/
   expression() <NEQ> expression()/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}

void cons_g()    : {/*@bgen(jjtree) g */
  ASTg jjtn000 = new ASTg(JJTG);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) g */
   try {
/*@egen*/
   expression() <G> expression()/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}

void cons_l()    : {/*@bgen(jjtree) l */
  ASTl jjtn000 = new ASTl(JJTL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) l */
   try {
/*@egen*/
   expression() <L> expression()/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}

void constraint() : {/*@bgen(jjtree) constraint */
  ASTconstraint jjtn000 = new ASTconstraint(JJTCONSTRAINT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) constraint */
  try {
/*@egen*/
  LOOKAHEAD(2)
  cons_eq() 
  | 
  LOOKAHEAD(2)
  cons_leq()
  |
  LOOKAHEAD(2)
  cons_geq() 
  |
  LOOKAHEAD(2)
  cons_l()
  |
  LOOKAHEAD(2)
  cons_g() 
  |
  cons_neq()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}


void atomic_expression()       : {} 
{
  variable() 
  |
  integer()
  |
  <LP> expression() <RP>
}


void multiplicative_expression()       : {}
{ 
  atomic_expression() 
  (
    ( <TIMES>/*@bgen(jjtree) #mul( 2) */
              {
                ASTmul jjtn001 = new ASTmul(JJTMUL);
                boolean jjtc001 = true;
                jjtree.openNodeScope(jjtn001);
              }
              try {
/*@egen*/ atomic_expression()/*@bgen(jjtree)*/
              } catch (Throwable jjte001) {
                if (jjtc001) {
                  jjtree.clearNodeScope(jjtn001);
                  jjtc001 = false;
                } else {
                  jjtree.popNode();
                }
                if (jjte001 instanceof RuntimeException) {
                  throw (RuntimeException)jjte001;
                }
                if (jjte001 instanceof ParseException) {
                  throw (ParseException)jjte001;
                }
                throw (Error)jjte001;
              } finally {
                if (jjtc001) {
                  jjtree.closeNodeScope(jjtn001,  2);
                }
              }
/*@egen*/         )
    |
    ( <DIV>/*@bgen(jjtree) #div( 2) */
            {
              ASTdiv jjtn002 = new ASTdiv(JJTDIV);
              boolean jjtc002 = true;
              jjtree.openNodeScope(jjtn002);
            }
            try {
/*@egen*/ atomic_expression()/*@bgen(jjtree)*/
            } catch (Throwable jjte002) {
              if (jjtc002) {
                jjtree.clearNodeScope(jjtn002);
                jjtc002 = false;
              } else {
                jjtree.popNode();
              }
              if (jjte002 instanceof RuntimeException) {
                throw (RuntimeException)jjte002;
              }
              if (jjte002 instanceof ParseException) {
                throw (ParseException)jjte002;
              }
              throw (Error)jjte002;
            } finally {
              if (jjtc002) {
                jjtree.closeNodeScope(jjtn002,  2);
              }
            }
/*@egen*/         )
  )*
}


void additive_expression()       : {}
{ 
  multiplicative_expression() 
  (
    (<PLUS>/*@bgen(jjtree) #plus( 2) */
            {
              ASTplus jjtn001 = new ASTplus(JJTPLUS);
              boolean jjtc001 = true;
              jjtree.openNodeScope(jjtn001);
            }
            try {
/*@egen*/ multiplicative_expression()/*@bgen(jjtree)*/
            } catch (Throwable jjte001) {
              if (jjtc001) {
                jjtree.clearNodeScope(jjtn001);
                jjtc001 = false;
              } else {
                jjtree.popNode();
              }
              if (jjte001 instanceof RuntimeException) {
                throw (RuntimeException)jjte001;
              }
              if (jjte001 instanceof ParseException) {
                throw (ParseException)jjte001;
              }
              throw (Error)jjte001;
            } finally {
              if (jjtc001) {
                jjtree.closeNodeScope(jjtn001,  2);
              }
            }
/*@egen*/          )
    |
    (<MINUS>/*@bgen(jjtree) #minus( 2) */
             {
               ASTminus jjtn002 = new ASTminus(JJTMINUS);
               boolean jjtc002 = true;
               jjtree.openNodeScope(jjtn002);
             }
             try {
/*@egen*/ multiplicative_expression()/*@bgen(jjtree)*/
             } catch (Throwable jjte002) {
               if (jjtc002) {
                 jjtree.clearNodeScope(jjtn002);
                 jjtc002 = false;
               } else {
                 jjtree.popNode();
               }
               if (jjte002 instanceof RuntimeException) {
                 throw (RuntimeException)jjte002;
               }
               if (jjte002 instanceof ParseException) {
                 throw (ParseException)jjte002;
               }
               throw (Error)jjte002;
             } finally {
               if (jjtc002) {
                 jjtree.closeNodeScope(jjtn002,  2);
               }
             }
/*@egen*/           )
  )*
}

void expression()       : {}
{
  additive_expression()
}


