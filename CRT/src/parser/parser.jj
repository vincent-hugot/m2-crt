/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. ./parser.jj */
/*@egen*/
/** 
 * Parser for the constraints.
 * by Vincent Hugot, 2009-10-4
 
 * This grammar has the following advantages over the one which was suggested:
 
  * More robust: Won't die if there are too many line feeds at the beginning or end...
  * Support for negative integers (the other did not!!)
  * AST expression trees correspond to the intuitive idea:
    +(2,3) instead of Exp(2,Exp(+,3)); visitors will be much
    easier to implement...
  * Expressions are (correctly) left-associative
  * Expressions support operator priorities
  * Supports parentheses to override priorities
    (the other had no priorities and no parens to explicitely
     specify them... the only possible way to get correct nesting would
     have been to introduce intermediary variables... a mess !)
  * Supports several constraints on one line, comma-separated
     
 * ... and the following difference
  * Domains must be grouped at beginning of file
    (can be seen as a restriction; 
     I see it as a cleaner way of doing things but YMMW)
  
**/

options {
	           
	             
	STATIC=false;
	ERROR_REPORTING=true; /* https://javacc.dev.java.net/doc/apiroutines.html Customizing Error Messages */
  //NODE_PACKAGE="parser";
    // For some reason, this option generates brain-dead "import .*"
    // which prevent compilation of generated files. So we'll do without it.
}

PARSER_BEGIN(Parser)
    public class Parser/*@bgen(jjtree)*/implements ParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTParserState jjtree = new JJTParserState();

/*@egen*/}
PARSER_END(Parser)


/** LEXER */

SKIP : { 
  " " | "\r" | "\t" | "\n" 
  /* Switch to comment block mode */
  | < OPEN_COMMENT_BLOCK : "/*"> : IN_COMMENT_BLOCK
}  

TOKEN : {

  /** Identifiers */

    < IDENTIFIER :  
      <LETTER> 
      | 
      (( <LETTER> | "_" ) ( <LETTER> | <DIGIT> | <SPECIALSYMB> )*) 
    >
  | < INTEGER :     ("-")? (<DIGIT>)+ >
  | < DIGIT :       ["0"-"9"] >
  | < LETTER :      ["a"-"z", "A"-"Z"] >
  | < SPECIALSYMB : ["_", "'"] >
      
  /** Keywords */
  
  | < DOMAINS:  "DOMAINS:">
  | < CONSTRAINTS: "CONSTRAINTS:">

  /** Symbols */

  | < LB:     "[" >
  | < RB:     "]" >
  | < LP:     "(" >
  | < RP:     ")" >
  | < BOUNDS: ",...,"|"..."|".." >
  | < COMMA:  "," >
  | < SEMICOLON: ";" >
  
  /** OPERATORS */

  | < DOMAIN_DEF:   ":" >

  | < PLUS:         "+" >
  | < MINUS:        "-">
  | < TIMES:        "*" >
  | < DIV:          "/" >

  | < NEQ:          "/="|"<>" >
  | < EQ:           "=" >

  | < LEQ:          "<=" > 
  | < GEQ:          ">=" >
  
  | < G:            ">" >
  | < L:            "<" >
  
} // END TOKENS 


<IN_COMMENT_BLOCK> SKIP : {
  "*/" : DEFAULT
}


<IN_COMMENT_BLOCK> MORE : {
  <~[]> 
}


MORE : {
    "//": IN_SINGLE_LINE_COMMENT 
}

      
< IN_SINGLE_LINE_COMMENT > SPECIAL_TOKEN : {
    < SINGLE_LINE_COMMENT: "\n"|"\r"|"\r\n" > : DEFAULT 
}

      
< IN_SINGLE_LINE_COMMENT > MORE : {
    <  ~[] >
} 


/** PARSER */

/* Rroot node */
SimpleNode constraints() : {/*@bgen(jjtree) constraints */
  ASTconstraints jjtn000 = new ASTconstraints(JJTCONSTRAINTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} 
{/*@bgen(jjtree) constraints */
  try {
/*@egen*/
  ( <DOMAINS>
    domain_definition() (<COMMA> domain_definition())* <SEMICOLON>
  )?
  (
    <CONSTRAINTS> constraint() (<COMMA> constraint())* <SEMICOLON>
  )?
  <EOF>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/ { return jjtn000; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void domain_definition()         : {/*@bgen(jjtree) domain */
        ASTdomain jjtn000 = new ASTdomain(JJTDOMAIN);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	jjtn000.setLine(getToken(1).beginLine);
}
{/*@bgen(jjtree) domain */
  try {
/*@egen*/
  variable() <DOMAIN_DEF> <LB> integer() <BOUNDS> integer() <RB>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}


void variable()      : {/*@bgen(jjtree) var */
        ASTvar jjtn000 = new ASTvar(JJTVAR);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	jjtn000.setLine(getToken(1).beginLine);
}
{/*@bgen(jjtree) var */
  try {
/*@egen*/
  <IDENTIFIER>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { 
       jjtn000.name = token.image; 
    }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void integer()          : {/*@bgen(jjtree) integer */
        ASTinteger jjtn000 = new ASTinteger(JJTINTEGER);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	jjtn000.setLine(getToken(1).beginLine);
	String value;
}
{/*@bgen(jjtree) integer */
  try {
/*@egen*/
  <INTEGER>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
      /*jjtThis.value = Integer.parseInt(token.image);*/
	  value = token.image; // String, then parsed with NumberFormatException
      jjtn000.setValue(value);
    }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void constraint() : {/*@bgen(jjtree) constraint */
                      ASTconstraint jjtn000 = new ASTconstraint(JJTCONSTRAINT);
                      boolean jjtc000 = true;
                      jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t;}
{/*@bgen(jjtree) constraint */
  try {
/*@egen*/
  expression()
  (
    (t= <EQ> expression()/*@bgen(jjtree) #eq( 2) */
                          {
                            ASTeq jjtn001 = new ASTeq(JJTEQ);
                            boolean jjtc001 = true;
                            jjtree.openNodeScope(jjtn001);
                          }
                          try {
/*@egen*//*@bgen(jjtree)*/
                          {
                            jjtree.closeNodeScope(jjtn001,  2);
                            jjtc001 = false;
                          }
/*@egen*/ {jjtn001.setLine(t.beginLine);}/*@bgen(jjtree)*/
                          } finally {
                            if (jjtc001) {
                              jjtree.closeNodeScope(jjtn001,  2);
                            }
                          }
/*@egen*/       )
    |
    (t=<NEQ> expression()/*@bgen(jjtree) #neq( 2) */
                          {
                            ASTneq jjtn002 = new ASTneq(JJTNEQ);
                            boolean jjtc002 = true;
                            jjtree.openNodeScope(jjtn002);
                          }
                          try {
/*@egen*//*@bgen(jjtree)*/
                          {
                            jjtree.closeNodeScope(jjtn002,  2);
                            jjtc002 = false;
                          }
/*@egen*/ {jjtn002.setLine(t.beginLine);}/*@bgen(jjtree)*/
                          } finally {
                            if (jjtc002) {
                              jjtree.closeNodeScope(jjtn002,  2);
                            }
                          }
/*@egen*/        )
    |
    (t=<LEQ> expression()/*@bgen(jjtree) #leq( 2) */
                          {
                            ASTleq jjtn003 = new ASTleq(JJTLEQ);
                            boolean jjtc003 = true;
                            jjtree.openNodeScope(jjtn003);
                          }
                          try {
/*@egen*//*@bgen(jjtree)*/
                          {
                            jjtree.closeNodeScope(jjtn003,  2);
                            jjtc003 = false;
                          }
/*@egen*/ {jjtn003.setLine(t.beginLine);}/*@bgen(jjtree)*/
                          } finally {
                            if (jjtc003) {
                              jjtree.closeNodeScope(jjtn003,  2);
                            }
                          }
/*@egen*/        )
    |
    (t=<GEQ> expression()/*@bgen(jjtree) #geq( 2) */
                          {
                            ASTgeq jjtn004 = new ASTgeq(JJTGEQ);
                            boolean jjtc004 = true;
                            jjtree.openNodeScope(jjtn004);
                          }
                          try {
/*@egen*//*@bgen(jjtree)*/
                          {
                            jjtree.closeNodeScope(jjtn004,  2);
                            jjtc004 = false;
                          }
/*@egen*/ {jjtn004.setLine(t.beginLine);}/*@bgen(jjtree)*/
                          } finally {
                            if (jjtc004) {
                              jjtree.closeNodeScope(jjtn004,  2);
                            }
                          }
/*@egen*/        )
    |
    (t=  <G> expression()/*@bgen(jjtree) #g( 2) */
                          {
                            ASTg jjtn005 = new ASTg(JJTG);
                            boolean jjtc005 = true;
                            jjtree.openNodeScope(jjtn005);
                          }
                          try {
/*@egen*//*@bgen(jjtree)*/
                          {
                            jjtree.closeNodeScope(jjtn005,  2);
                            jjtc005 = false;
                          }
/*@egen*/ {jjtn005.setLine(t.beginLine);}/*@bgen(jjtree)*/
                          } finally {
                            if (jjtc005) {
                              jjtree.closeNodeScope(jjtn005,  2);
                            }
                          }
/*@egen*/      )
    |
    (t=  <L> expression()/*@bgen(jjtree) #l( 2) */
                          {
                            ASTl jjtn006 = new ASTl(JJTL);
                            boolean jjtc006 = true;
                            jjtree.openNodeScope(jjtn006);
                          }
                          try {
/*@egen*//*@bgen(jjtree)*/
                          {
                            jjtree.closeNodeScope(jjtn006,  2);
                            jjtc006 = false;
                          }
/*@egen*/ {jjtn006.setLine(t.beginLine);}/*@bgen(jjtree)*/
                          } finally {
                            if (jjtc006) {
                              jjtree.closeNodeScope(jjtn006,  2);
                            }
                          }
/*@egen*/      )
  )/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}


void atomic_expression()       : {} 
{
  variable() 
  |
  integer()
  |
  <LP> expression() <RP>
}


void multiplicative_expression()       : {
	Token t;
}
{ 
  atomic_expression() 
  (
    ( t=<TIMES> atomic_expression()/*@bgen(jjtree) #mul( 2) */
                                    {
                                      ASTmul jjtn001 = new ASTmul(JJTMUL);
                                      boolean jjtc001 = true;
                                      jjtree.openNodeScope(jjtn001);
                                    }
                                    try {
/*@egen*//*@bgen(jjtree)*/
                                    {
                                      jjtree.closeNodeScope(jjtn001,  2);
                                      jjtc001 = false;
                                    }
/*@egen*/ {jjtn001.setLine(t.beginLine);}/*@bgen(jjtree)*/
                                    } finally {
                                      if (jjtc001) {
                                        jjtree.closeNodeScope(jjtn001,  2);
                                      }
                                    }
/*@egen*/         )
    |
    ( t=<DIV> atomic_expression()/*@bgen(jjtree) #div( 2) */
                                  {
                                    ASTdiv jjtn002 = new ASTdiv(JJTDIV);
                                    boolean jjtc002 = true;
                                    jjtree.openNodeScope(jjtn002);
                                  }
                                  try {
/*@egen*//*@bgen(jjtree)*/
                                  {
                                    jjtree.closeNodeScope(jjtn002,  2);
                                    jjtc002 = false;
                                  }
/*@egen*/ {jjtn002.setLine(t.beginLine);}/*@bgen(jjtree)*/
                                  } finally {
                                    if (jjtc002) {
                                      jjtree.closeNodeScope(jjtn002,  2);
                                    }
                                  }
/*@egen*/         )
  )*
}


void additive_expression()       : {
	Token t;
}
{ 
  multiplicative_expression() 
  (
    ( t=<PLUS> multiplicative_expression()/*@bgen(jjtree) #plus( 2) */
                                           {
                                             ASTplus jjtn001 = new ASTplus(JJTPLUS);
                                             boolean jjtc001 = true;
                                             jjtree.openNodeScope(jjtn001);
                                           }
                                           try {
/*@egen*//*@bgen(jjtree)*/
                                           {
                                             jjtree.closeNodeScope(jjtn001,  2);
                                             jjtc001 = false;
                                           }
/*@egen*/ {jjtn001.setLine(t.beginLine);}/*@bgen(jjtree)*/
                                           } finally {
                                             if (jjtc001) {
                                               jjtree.closeNodeScope(jjtn001,  2);
                                             }
                                           }
/*@egen*/          )
    |
    ( t=<MINUS> multiplicative_expression()/*@bgen(jjtree) #minus( 2) */
                                            {
                                              ASTminus jjtn002 = new ASTminus(JJTMINUS);
                                              boolean jjtc002 = true;
                                              jjtree.openNodeScope(jjtn002);
                                            }
                                            try {
/*@egen*//*@bgen(jjtree)*/
                                            {
                                              jjtree.closeNodeScope(jjtn002,  2);
                                              jjtc002 = false;
                                            }
/*@egen*/ {jjtn002.setLine(t.beginLine);}/*@bgen(jjtree)*/
                                            } finally {
                                              if (jjtc002) {
                                                jjtree.closeNodeScope(jjtn002,  2);
                                              }
                                            }
/*@egen*/           )
  )*
}

void expression()       : {}
{
  additive_expression()
}


